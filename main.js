/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => UrlInternalViewerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  openInBrowser: false,
  fullscreenMode: false
};
var VIEW_TYPE_WEB = "url-webview";
var UrlInternalViewerPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerView(VIEW_TYPE_WEB, (leaf) => new UrlWebView(leaf, this));
    this.registerExtensions(["url"], VIEW_TYPE_WEB);
    this.addSettingTab(new UrlViewerSettingTab(this.app, this));
    this.addCreateUrlFileShortcuts();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.refreshViews();
  }
  refreshViews() {
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view instanceof UrlWebView) {
        leaf.view.updateFullscreenMode();
      }
    });
  }
  addCreateUrlFileShortcuts() {
    this.addRibbonIcon("link-2", "Create .url file", async () => await this.createAndEditUrlFile());
    this.addCommand({
      id: "create-url-file",
      name: "Create .url file",
      callback: async () => await this.createAndEditUrlFile()
    });
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file, _source) => {
        if (file instanceof import_obsidian.TFolder) {
          menu.addItem(
            (item) => item.setTitle("Create .url file").setIcon("link-2").onClick(async () => await this.createAndEditUrlFile(file.path + "/URL " + Date.now() + ".url"))
          );
        } else if (file instanceof import_obsidian.TFile && file.extension === "url") {
          menu.addItem(
            (item) => item.setTitle("Edit URL").setIcon("edit").onClick(async () => {
              const leaf = this.app.workspace.getLeaf(true);
              await leaf.openFile(file);
              const view = leaf.view;
              if (view instanceof UrlWebView) {
                view.startEditing(false);
              }
            })
          );
        }
      })
    );
  }
  async createAndEditUrlFile(path) {
    var _a;
    const fileName = `URL ${Date.now()}.url`;
    const content = `[InternetShortcut]
URL=
`;
    if (path == null) {
      const activeFile = this.app.workspace.getActiveFile();
      const parentFolder = this.app.fileManager.getNewFileParent((_a = activeFile == null ? void 0 : activeFile.path) != null ? _a : "");
      path = (0, import_obsidian.normalizePath)(`${parentFolder.path}/${fileName}`);
    }
    const created = await this.app.vault.create(path, content);
    const leaf = this.app.workspace.getLeaf(true);
    await leaf.openFile(created);
    const view = leaf.view;
    if (view instanceof UrlWebView) {
      view.startEditing(true);
    }
  }
};
var UrlWebView = class extends import_obsidian.FileView {
  constructor(leaf, plugin) {
    super(leaf);
    this.isEditing = false;
    this.headerHidden = false;
    this.webviewEl = null;
    this.backActionEl = null;
    this.forwardActionEl = null;
    this.deleteOnCancelIfUntouched = false;
    this.plugin = plugin;
  }
  get settings() {
    return this.plugin.settings;
  }
  extractUrl(content) {
    let url = content.trim();
    if (content.includes("[InternetShortcut]")) {
      const match = content.match(/URL=(.+)/);
      if (match) url = match[1].trim();
    }
    return this.normalizeUrl(url);
  }
  getViewType() {
    return VIEW_TYPE_WEB;
  }
  getDisplayText() {
    var _a;
    return ((_a = this.file) == null ? void 0 : _a.basename) || "URL Viewer";
  }
  async onOpen() {
    this.containerEl.addClass("url-webview-opener");
    this.updateFullscreenMode();
    this.addAction("edit", "Edit URL", () => this.toggleEditMode());
    this.addAction("external-link", "Open in browser", () => this.openInBrowser());
    this.addAction("refresh-cw", "Reload", () => this.webviewReload());
    this.addAction("arrow-right", "Forward", () => this.webviewGoForward());
    this.addAction("arrow-left", "Back", () => this.webviewGoBack());
  }
  updateFullscreenMode() {
    if (this.settings.fullscreenMode) {
      this.containerEl.addClass("fullscreen-mode");
      this.headerHidden = true;
      this.containerEl.addClass("header-hidden");
    } else {
      this.containerEl.removeClass("fullscreen-mode");
      this.headerHidden = false;
      this.containerEl.removeClass("header-hidden");
    }
  }
  async onLoadFile(file) {
    const content = await this.app.vault.read(file);
    const url = this.extractUrl(content);
    setTimeout(() => {
      if (this.isEditing || !isValidUrl(url)) {
        this.showEditMode(file, content);
      } else {
        if (this.settings.openInBrowser) {
          window.open(url, "_blank");
          this.leaf.detach();
          return;
        } else {
          this.showViewMode(url);
        }
      }
    }, 0);
  }
  updateActionStates() {
    if (!isWebviewTag(this.webviewEl)) return;
    if (this.backActionEl) {
      this.webviewEl.canGoBack().then((canGoBack) => {
        if (this.backActionEl) this.backActionEl.toggleClass("is-disabled", !canGoBack);
      });
    }
    if (this.forwardActionEl) {
      this.webviewEl.canGoForward().then((canGoForward) => {
        if (this.forwardActionEl) this.forwardActionEl.toggleClass("is-disabled", !canGoForward);
      });
    }
  }
  webviewGoBack() {
    if (isWebviewTag(this.webviewEl)) this.webviewEl.goBack();
  }
  webviewGoForward() {
    if (isWebviewTag(this.webviewEl)) this.webviewEl.goForward();
  }
  webviewReload() {
    if (isWebviewTag(this.webviewEl)) this.webviewEl.reload();
  }
  showViewMode(url) {
    const container = this.containerEl.children[1];
    container.empty();
    const webviewEl = document.createElement("webview");
    if (!isWebviewTag(webviewEl)) {
      console.error("webviewEl is not a WebviewTag");
      return;
    }
    webviewEl.src = url;
    webviewEl.setAttribute("style", "width:100%;height:100%;");
    container.appendChild(webviewEl);
    this.webviewEl = webviewEl;
    const actions = this.containerEl.querySelectorAll(".view-action");
    this.backActionEl = actions[0];
    this.forwardActionEl = actions[1];
    const updateNav = () => this.updateActionStates();
    webviewEl.addEventListener("did-navigate", updateNav);
    webviewEl.addEventListener("did-navigate-in-page", updateNav);
    webviewEl.addEventListener("dom-ready", updateNav);
    if (this.settings.fullscreenMode) {
      const chevron = container.createEl("div", {
        cls: "chevron-toggle",
        text: "\u27E9"
      });
      chevron.onclick = () => this.toggleHeader();
    }
  }
  toggleHeader() {
    this.headerHidden = !this.headerHidden;
    if (this.headerHidden) {
      this.containerEl.addClass("header-hidden");
    } else {
      this.containerEl.removeClass("header-hidden");
    }
    const chevron = this.containerEl.querySelector(".chevron-toggle");
    if (chevron) chevron.textContent = "\u27E9";
  }
  showEditMode(file, content) {
    const container = this.containerEl.children[1];
    container.empty();
    const editContainer = container.createDiv("url-webview-opener-edit");
    const textarea = editContainer.createEl("textarea", { cls: "url-textarea" });
    textarea.value = content;
    const btnContainer = editContainer.createDiv("url-edit-buttons");
    const saveBtn = btnContainer.createEl("button", { text: "Save", cls: "btn-edit" });
    saveBtn.onclick = async () => {
      await this.app.vault.modify(file, textarea.value);
      this.isEditing = false;
      await this.onLoadFile(file);
    };
    const cancelBtn = btnContainer.createEl("button", { text: "Cancel", cls: "btn-edit" });
    cancelBtn.onclick = async () => {
      if (this.deleteOnCancelIfUntouched) {
        const currentContent = await this.app.vault.read(file);
        if (this.isEmptyUrlContent(currentContent)) {
          await this.app.vault.delete(file);
          this.isEditing = false;
          this.deleteOnCancelIfUntouched = false;
          this.leaf.detach();
          return;
        }
      }
      this.isEditing = false;
      this.deleteOnCancelIfUntouched = false;
      this.onLoadFile(file);
    };
  }
  normalizeUrl(url) {
    const trimmed = url.trim();
    if (!trimmed) return trimmed;
    if (/^[a-zA-Z][a-zA-Z0-9+.+-]*:/.test(trimmed)) return trimmed;
    const withoutSlashes = trimmed.replace(/^\/\//, "");
    return `https://${withoutSlashes}`;
  }
  startEditing(deleteOnCancelIfUntouched = false) {
    this.isEditing = true;
    this.deleteOnCancelIfUntouched = deleteOnCancelIfUntouched;
    if (this.file != null) this.onLoadFile(this.file);
  }
  isEmptyUrlContent(content) {
    var _a;
    const trimmed = content.trim();
    if (trimmed.length === 0) return true;
    if (trimmed.includes("[InternetShortcut]")) {
      const match = content.match(/URL=(.*)/);
      if (!match) return true;
      const value = ((_a = match[1]) != null ? _a : "").trim();
      return value.length === 0;
    }
    return trimmed.length === 0;
  }
  toggleEditMode() {
    this.isEditing = !this.isEditing;
    if (this.file) this.onLoadFile(this.file);
  }
  async openInBrowser() {
    if (this.file) {
      const content = await this.app.vault.read(this.file);
      const url = this.extractUrl(content);
      window.open(url, "_blank");
    }
  }
};
var UrlViewerSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Open in browser by default").setDesc("Open URL files directly in browser instead of webview").addToggle((toggle) => toggle.setValue(this.plugin.settings.openInBrowser).onChange(async (value) => {
      this.plugin.settings.openInBrowser = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Fullscreen mode").setDesc("Hide toolbar and show floating navigation buttons for maximum space").addToggle((toggle) => toggle.setValue(this.plugin.settings.fullscreenMode).onChange(async (value) => {
      this.plugin.settings.fullscreenMode = value;
      await this.plugin.saveSettings();
    }));
  }
};
function isWebviewTag(el) {
  return !!el && typeof el.reload === "function" && typeof el.goBack === "function" && typeof el.goForward === "function";
}
function isValidUrl(url) {
  try {
    new URL(url);
    return true;
  } catch (error) {
    return false;
  }
}
